# CIT Elevators
We decided to model the elevators in the CIT using Alloy. The basic structure of our model is a series of states, where each state keeps track of which floor each elevator is on, which floor each person is on, and which people are passengers on which elevators. When transitioning between each state, each elevator must either move up or down one floor, load passengers, or unload passengers. In the beginning, each person is on a floor that is not their destination, and no people are on elevators. In the end state, each person is on their destination floor, and no one is on an elevator. Obviously, there is a frame condition that people not on elevators cannot change floors. Thus, it takes a minimum of four states to move one person one floor; they start on one floor, then they get on the elevator in the second state, then the elevator moves between the second and third states, then they get off to finish in the fourth state.

We modeled three main elevator systems, or ways to organize which elevators go to which floors. First, in an ideal world, the elevators would be able to coordinate without restrictions to find the most efficient way to move passengers. We called this model "no restrictions." Second, we observed that frequently in the CIT, people press the button for both elevators, requiring one of them to come unnecessarily. We modeled this secenario using the predicate call\_both, which requires both elevators to visit each floor which has a person on it in the initial state. We also modeled the restriction that one elevator stays below the fourth floor using the predicate below\_fourth. This made sense intuitively as a model since there is less traffic on the fourth and fifth floors of the CIT; however, since we could not model these traffic patterns in Alloy, our model only gives a general idea of the effect of this restriction.  For each of these, we also saw if it made a difference if both elevators started on the first floor, which we thought was more realistic, versus without constraints on starting location.

We tested these systems on three passenger scenarios, all designed using predicates. The first was two passengers going to different floors. The second was two passengers who start and end at least two floors apart from each other. The first was three passengers, each of whom starts and ends on a different floor, causing all six floors to be used. We plugged these predicated into run statements by hand to determine the minimum number of states required to get all passengers to their destinations in each of these scenarios with each elevator system. Our results are reported in a table below. It is important to note a main constraint of our model: we assume that a set of people all arrive at the same time, and no new people enter the model as time passes. Also, Alloy can position the passengers, subject to our constraints, in the most optimal way to minimize the number of states. This is obviously unrealistic, and thus, this is not an exhaustive analysis of which elevator system is most efficient. However, it does give an idea of pros and cons of each system, especially looking at different instances.


| | Different Destinations| Start and End 2 Apart | All Floors Used| Average |
| --- | :---: | :---: | :---: | :---: |
| No Restrictions | 4 | 4 | 8 | 5.33 |
| Start on 1st Floor | 4 | 5 | 9 | 6 |
| Both Elevators Called | 4 | 5 | 9 | 6 |
| Both Called, Start on 1st| 4 | 6 | 9 | 6.33 |
| One Below Fourth Floor| 4 | 4 | 8 | 5.33 |
| One Below 4th, Start on 1st| 4 | 5 | 9 | 6 |
